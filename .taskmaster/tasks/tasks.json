{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js 15 Project with TypeScript, Tailwind, shadcn/ui",
        "description": "Scaffold the Next.js 15 App Router project with TypeScript, Tailwind CSS, and shadcn/ui; set up project conventions and base config.",
        "details": "- Use Node 20 LTS. npx create-next-app@latest auctoa-analytics --ts --eslint --src-dir --app --tailwind --import-alias @/*\n- Verify Next.js 15 canary/stable; enable experimental App Router features if needed in next.config.mjs.\n- Tailwind: configure tailwind.config.ts with shadcn/ui preset and dark mode 'class'.\n- Install shadcn/ui CLI (latest) and initialize; import base components (button, card, input, select, dialog, dropdown-menu, navigation-menu, sheet, toast, tooltip, chart primitives if available).\n- Install lucide-react ^0.447.0.\n- Set up absolute imports @/* and module path mapping in tsconfig.json.\n- Configure ESLint with next/core-web-vitals, TypeScript rules; Prettier.\n- Add commit hooks: Husky + lint-staged; configure pnpm work if desired; use pnpm as package manager.\n- Set up environment variables via .env.local.example (NEXTAUTH_SECRET, NEXTAUTH_URL, SUPABASE_URL, SUPABASE_ANON_KEY, GOOGLE creds, GA4, GADS, GSC, NEWS/Alerts, CHATBOT API, N8N_WEBHOOK_URL).",
        "testStrategy": "- Run npm run build and npm run lint to ensure zero errors.\n- Validate shadcn components render in a sample page.\n- Confirm Tailwind classes apply and dark mode toggles.\n- Ensure TypeScript strict mode compiles without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Next.js 15 project with TypeScript and App Router",
            "description": "Create a new Next.js 15 project using create-next-app with TypeScript, App Router, Tailwind, ESLint, and src dir.",
            "dependencies": [],
            "details": "Use Node 20 LTS. Run: npx create-next-app@latest auctoa-analytics --ts --eslint --src-dir --app --tailwind --import-alias @/* . Verify Next.js 15 installed and App Router is enabled by default in /app. Confirm next.config.ts support if desired.",
            "status": "done",
            "testStrategy": "Run pnpm dev to ensure app starts; check /app/page.tsx renders; run pnpm build without errors."
          },
          {
            "id": 2,
            "title": "Configure Next.js 15 settings and experimental flags",
            "description": "Set up next.config.ts/mjs with Next.js 15 options and any required experimental App Router features.",
            "dependencies": [
              "1.1"
            ],
            "details": "Migrate to next.config.ts and type with NextConfig. Enable or confirm features as needed (e.g., caching, route handlers). Add basePath, experimental or future flags only if required by dependencies. Commit configuration.",
            "status": "done",
            "testStrategy": "Run pnpm build to validate config types; ensure no deprecation warnings; verify dev server starts with new config."
          },
          {
            "id": 3,
            "title": "Install and configure Tailwind CSS with shadcn/ui preset",
            "description": "Set Tailwind dark mode, content paths, and integrate shadcn/ui preset in tailwind.config.ts.",
            "dependencies": [
              "1.1"
            ],
            "details": "Set darkMode: 'class'. Configure content to scan ./app/**/*.{ts,tsx}, ./components/**/*.{ts,tsx}, ./src/**/*.{ts,tsx}. Add shadcn/ui preset if available, or extend theme tokens to match shadcn requirements. Create globals.css with @tailwind base, components, utilities and CSS variables for themes.",
            "status": "done",
            "testStrategy": "Add a sample page using Tailwind classes and toggle dark mode via class on html; verify styles apply and no purge issues."
          },
          {
            "id": 4,
            "title": "Install shadcn/ui, base components, and icon library",
            "description": "Initialize shadcn/ui CLI, configure component path, and add core components with lucide-react.",
            "dependencies": [
              "1.1",
              "1.2",
              "1.3"
            ],
            "details": "Install shadcn/ui CLI and init. Configure components directory (e.g., components/ui). Add components: button, card, input, select, dialog, dropdown-menu, navigation-menu, sheet, toast, tooltip, and chart primitives if available. Install lucide-react ^0.447.0. Create a sample page rendering imported components to verify.",
            "status": "done",
            "testStrategy": "Render multiple shadcn components on a sample route; ensure no CSS or type errors; verify icons render."
          },
          {
            "id": 5,
            "title": "Set up project tooling: TypeScript paths, ESLint/Prettier, Husky, lint-staged, env templates, and pnpm",
            "description": "Configure tsconfig paths (@/*), ESLint with next/core-web-vitals and TypeScript rules, Prettier, commit hooks, and .env.local.example.",
            "dependencies": [
              "1.1"
            ],
            "details": "Update tsconfig.json compilerOptions.paths to map @/* to ./src/* (or project structure). Configure ESLint extends: next/core-web-vitals and TypeScript rules; add Prettier config and plugin. Install Husky and lint-staged; set pre-commit to run eslint --fix and prettier --check on staged files. Ensure pnpm is set as package manager. Add .env.local.example with NEXTAUTH_SECRET, NEXTAUTH_URL, SUPABASE_URL, SUPABASE_ANON_KEY, GOOGLE creds, GA4, GADS, GSC, NEWS/Alerts, CHATBOT API, N8N_WEBHOOK_URL.",
            "status": "done",
            "testStrategy": "Run pnpm lint with zero errors; commit a change and verify pre-commit hooks run; TypeScript build in strict mode passes; verify absolute imports compile."
          }
        ]
      },
      {
        "id": 2,
        "title": "Design System Setup: Theme, Typography, Colors, WCAG Baseline",
        "description": "Establish a cohesive design system with Tailwind tokens, shadcn theme, and accessibility foundations, emphasizing modern, clean, and visually appealing design as the top priority.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "CRITICAL DESIGN REQUIREMENTS:\n- Modern, clean interface with plenty of white space\n- Professional color scheme and typography\n- Enterprise-grade visual aesthetics\n- Smooth animations and micro-interactions\n- Intuitive information hierarchy\n- Mobile-responsive design patterns\n- Accessibility compliance (WCAG)\n\nIMPLEMENTATION:\n- Use Tailwind CSS variables for color tokens (primary, secondary, accent, success, warning, danger, muted, background, foreground) with HSL.\n- Generate light/dark palettes; ensure contrast ratios â‰¥ 4.5:1 for body text while maintaining visual appeal.\n- Configure shadcn theme with CSS variables; include focus states and motion-safe animations that enhance user experience.\n- Set base typography scale, spacing, radii; import Inter or Geist via next/font for professional typography.\n- Establish comprehensive spacing scales that promote ample white space and clean layouts.\n- Create design tokens for elevation (shadows), borders, and transitions that reinforce the modern aesthetic.\n- Create reusable UI patterns with emphasis on visual polish: KPI Card, Section Header, Stat Delta (trend up/down with colors), Empty State, Skeleton Loader.\n- Implement subtle micro-interactions and transitions to enhance perceived quality.\n- Document components in a Storybook 8 setup for visual regression (optional but recommended for internal).\n- Add aria attributes and keyboard navigation patterns to nav components.\n- Design component variants that maintain visual consistency while offering flexibility.",
        "testStrategy": "- Use axe-core/Playwright to check for zero critical accessibility violations.\n- Manually test keyboard navigation and focus order.\n- Visual regression snapshots of components in Storybook.\n- Conduct design reviews focused on visual appeal, white space usage, and professional appearance.\n- Test animations and transitions for smoothness across devices.\n- Verify information hierarchy through user testing or expert review.\n- Ensure responsive design patterns maintain visual integrity across breakpoints.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create color token system with professional palette",
            "description": "Develop a sophisticated color system with primary, secondary, and accent colors that convey enterprise-grade professionalism while maintaining accessibility.",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-08-12T12:52:04.121Z>\nEnhanced color token system with professional palette\n\nIMPROVEMENTS MADE:\n- Upgraded primary color to modern blue (#1d4ed8) with proper OKLCH values\n- Enhanced secondary colors with blue-gray tones for enterprise look\n- Added analytics orange accent color for highlights\n- Converted all status colors (success, warning, danger) to OKLCH for consistency\n- Added new 'info' color category for informational states\n- Improved dark mode color variants with proper contrast ratios\n- All colors now follow OKLCH color space for better perceptual uniformity\n\nCOLORS ESTABLISHED:\n- Primary: Modern blue with high contrast\n- Secondary: Light blue-gray for subtle backgrounds\n- Accent: Analytics orange for key highlights\n- Status: Success (emerald), Warning (amber), Danger (red), Info (blue)\n- Chart colors: 5-color palette for data visualization\n\nThe color system is now enterprise-grade and ready for professional analytics dashboard use.\n</info added on 2025-08-12T12:52:04.121Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Establish typography system with clear hierarchy",
            "description": "Configure typography scales that create clear visual hierarchy and maintain readability, using Inter or Geist font with appropriate weight and size variations.",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-08-12T12:53:05.414Z>\nâœ… Established professional typography system with clear hierarchy\n\nTYPOGRAPHY ENHANCEMENTS:\n- Added Inter font family as primary typeface (professional, readable)\n- Added JetBrains Mono for code/monospace content\n- Created complete typography scale (xs to 4xl) with proper sizing\n- Established line height system (tight, normal, relaxed)\n- Set up font weight hierarchy (400-700)\n- Enhanced body typography with proper font features and smoothing\n\nHIERARCHY CLASSES CREATED:\n- Heading styles (h1-h6) with appropriate sizing and weights\n- Semantic text utilities (.text-display, .text-headline, .text-title, etc.)\n- Analytics-specific classes (.text-metric, .text-metric-large) with tabular numbers\n- Professional spacing and tracking for optimal readability\n\nACCESSIBILITY FEATURES:\n- Optimized font rendering for clarity\n- Proper contrast ratios maintained\n- Tabular numbers for consistent metric display\n- Tracking adjustments for better readability at different sizes\n\nThe typography system now provides clear visual hierarchy and enterprise-level professionalism for the analytics dashboard.\n</info added on 2025-08-12T12:53:05.414Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Design spacing and layout system",
            "description": "Create spacing scales and layout patterns that emphasize white space and clean composition, establishing consistent margins, paddings, and gaps.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement animation and transition system",
            "description": "Develop subtle, professional animations and micro-interactions that enhance the UI without being distracting, with motion-safe alternatives.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create core UI component patterns",
            "description": "Design and implement visually polished versions of KPI Card, Section Header, Stat Delta, Empty State, and Skeleton Loader components.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Configure responsive design tokens",
            "description": "Establish responsive breakpoints and container queries that maintain visual integrity and professional appearance across all device sizes.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Document design system in Storybook",
            "description": "Create comprehensive documentation of the design system components, tokens, and usage guidelines in Storybook 8.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Core Layout, Routing, and Navigation",
        "description": "Implement visually stunning, responsive layout with sidebar, header, breadcrumbs, and section routes using App Router, emphasizing clean design principles and professional visual hierarchy.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "- App Router structure: app/(dashboard)/layout.tsx with Sidebar, Header, Breadcrumbs; pages: /, /search-performance, /website-analytics, /chatbot-analytics, /campaign-performance, /settings.\n- Design Focus: Clean, modern layout with abundant white space; professional enterprise-grade visual hierarchy; intuitive information architecture.\n- Sidebar: collapsible, icons via lucide-react; active route highlighting; mobile Sheet for small screens; elegant design with smooth transition animations.\n- Header: polished user menu, search input (debounced), notifications dropdown; consistent visual styling.\n- Breadcrumbs: derive from segment; add aria-label; integrate seamlessly with overall design.\n- Responsive grid system using Tailwind (grid-cols-12) and container queries with mobile-first approach.\n- Animations: Implement smooth navigation transitions between routes; subtle hover effects; loading state animations.\n- Visual Consistency: Maintain consistent spacing, typography, and color usage across all sections.\n- Error boundary and loading.tsx for each route with visually appealing states.\n- Add NotFound and global toasts with design-consistent styling.",
        "testStrategy": "- Lighthouse check for responsive behavior and visual performance.\n- Verify routing works and loading/error states render per route with smooth transitions.\n- Keyboard navigation across sidebar/header with screen reader labels.\n- Test visual consistency across different viewport sizes.\n- Validate animation performance on lower-end devices.\n- Ensure design maintains integrity across all major breakpoints.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base layout structure with visual hierarchy",
            "description": "Implement app/(dashboard)/layout.tsx with Sidebar, Header, and Breadcrumbs components focusing on clean design and white space",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-08-12T13:07:56.586Z>\nCOMPLETED: Base layout structure implemented with (dashboard) route group, main layout.tsx, Sidebar, and Header.\n\nWhat was built:\n- Route group app/(dashboard) with pages: /, /analytics, /search, /chatbot, /settings\n- Main layout with clean visual hierarchy and component separation\n- Sidebar (collapsible, active route highlight, smooth animations)\n- Header (search, notifications dropdown, user menu)\n- Responsive main content container with consistent padding\n\nTechnical decisions:\n- Tailwind-based professional gray/white scheme\n- lucide-react icons; animations via Tailwind transitions\n- Placeholder user and notifications for MVP\n- Collapsible sidebar retains icon visibility when collapsed\n\nNext steps:\n- Proceed to Subtask 3.5 for responsive behavior and mobile navigation (Sidebar Sheet on small screens, header adaptations, keyboard focus management)\n</info added on 2025-08-12T13:07:56.586Z>\n<info added on 2025-08-12T13:23:50.955Z>\nâœ… COMPLETED: Base layout structure with professional dark mode support\n\n**What was accomplished:**\n- âœ… Complete dashboard layout with collapsible sidebar and professional header\n- âœ… Working navigation between all dashboard sections (Overview, Analytics, Search, Chatbot, Settings)\n- âœ… Professional dark mode implementation with proper color schemes\n- âœ… State persistence for dark mode preference using localStorage\n- âœ… Responsive design with smooth transitions and hover effects\n- âœ… Clean, enterprise-grade visual hierarchy throughout all components\n\n**Technical achievements:**\n- Proper Tailwind dark mode classes across all layout components\n- Semantic color usage (bg-background, text-muted-foreground, etc.)\n- Professional sidebar with active route highlighting\n- Header with search, notifications, dark mode toggle, and user menu\n- Consistent border and spacing systems\n\n**Ready for next phase:** Data integration from Supabase\n</info added on 2025-08-12T13:23:50.955Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design and implement elegant sidebar",
            "description": "Create collapsible sidebar with Lucide icons, active route highlighting, and smooth transition animations",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop polished header component",
            "description": "Build header with user menu, debounced search input, and notifications dropdown with consistent styling",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement responsive grid system",
            "description": "Create mobile-first responsive grid using Tailwind and container queries with attention to visual consistency",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add route transitions and animations",
            "description": "Implement smooth navigation animations and transitions between routes for a polished user experience",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create visually appealing loading and error states",
            "description": "Design and implement loading.tsx and error boundary components for each route with consistent styling",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Authentication with NextAuth.js and Supabase Adapter",
        "description": "Secure internal access via NextAuth with OAuth (Google) and email link; protect routes and APIs.",
        "details": "- Install next-auth ^5, set up Route Handlers in app/api/auth/[...nextauth]/route.ts.\n- Use Supabase as session/user adapter or keep NextAuth default with Prisma; PRD mandates Supabase for DB, so use @auth/supabase-adapter or custom tables in Supabase.\n- Providers: Google OAuth (internal domain allowlist) and Email (magic link) via Supabase SMTP or Resend.\n- Session strategy: jwt with encryption; set secure cookies; NEXTAUTH_URL set for prod.\n- Protect App Router segments with middleware.ts to require auth for /(dashboard) routes.\n- Restrict API routes by verifying session in route handlers.\n- Add role field for future RBAC (enum: admin, analyst, viewer).",
        "testStrategy": "- Unit test auth callbacks (signIn, jwt, session) with mocked requests.\n- Manual sign-in flows; verify unauthorized users redirected.\n- Validate CSRF and cookie secure flags in prod build.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure NextAuth.js with Supabase Adapter",
            "description": "Set up NextAuth.js v5 in the Next.js project, install @auth/supabase-adapter, and configure Route Handlers in app/api/auth/[...nextauth]/route.ts to use Supabase as the session and user adapter.",
            "dependencies": [],
            "details": "Install next-auth and @auth/supabase-adapter packages. Configure NextAuth.js to use Supabase for user and session management, referencing Supabase project URL and service role key in environment variables. Ensure the adapter is correctly initialized in the NextAuth config.",
            "status": "pending",
            "testStrategy": "Verify installation and configuration by running the app and confirming NextAuth endpoints respond. Check that users and sessions are stored in Supabase after authentication."
          },
          {
            "id": 2,
            "title": "Set Up Supabase Database Schema and Enable Row Level Security (RLS)",
            "description": "Create the required tables and schema in Supabase for NextAuth (users, accounts, sessions, verification tokens) and enable RLS for secure data access.",
            "dependencies": [
              "4.1"
            ],
            "details": "Use Supabase SQL editor to run schema creation scripts for NextAuth tables. Enable RLS on these tables and configure policies to restrict access based on authenticated user JWT. Store the Supabase JWT secret for signing tokens in NextAuth callbacks.",
            "status": "pending",
            "testStrategy": "Check that tables are created and RLS is active. Attempt unauthorized access to confirm RLS blocks it. Validate that authenticated users can access only their own data."
          },
          {
            "id": 3,
            "title": "Configure Authentication Providers: Google OAuth and Email Magic Link",
            "description": "Set up Google OAuth provider with internal domain allowlist and configure email magic link authentication using Supabase SMTP or Resend.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Add Google provider to NextAuth config, restricting sign-in to allowed domains. Configure email provider for passwordless login, setting up SMTP credentials in Supabase or integrating Resend. Ensure verification tokens are stored in Supabase.",
            "status": "pending",
            "testStrategy": "Test sign-in flows for both providers. Confirm only allowed domains can sign in via Google. Verify email magic link delivery and successful authentication."
          },
          {
            "id": 4,
            "title": "Implement Secure Session Strategy and Cookie Settings",
            "description": "Configure NextAuth to use JWT session strategy with encryption, set secure cookies, and ensure NEXTAUTH_URL is set for production.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Set session strategy to 'jwt' in NextAuth config. Use Supabase JWT secret to sign tokens in session callback. Configure cookies to be secure and HTTP-only. Set NEXTAUTH_URL environment variable for production deployment.",
            "status": "pending",
            "testStrategy": "Unit test session and JWT callbacks with mocked requests. Validate cookies are secure and have correct flags in production. Confirm session tokens are encrypted and valid."
          },
          {
            "id": 5,
            "title": "Protect Application Routes and APIs with Middleware and Role Field",
            "description": "Use middleware.ts to require authentication for protected routes (e.g., /dashboard) and restrict API routes by verifying session. Add a role field to user records for future RBAC.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Implement middleware.ts to check authentication for protected segments. In API route handlers, verify session before processing requests. Extend Supabase user schema to include a role enum (admin, analyst, viewer) for future role-based access control.",
            "status": "pending",
            "testStrategy": "Manually test route protection by accessing protected routes as authenticated and unauthenticated users. Confirm unauthorized users are redirected. Validate role field is present and correctly set in user records."
          }
        ]
      },
      {
        "id": 5,
        "title": "Supabase Schema Design and Client Setup",
        "description": "Create schemas for metrics, data sources, and logs; configure Supabase client for server and edge.",
        "details": "- Install @supabase/supabase-js ^2.45.0.\n- Schema: tables\n  - data_sources(id, name, type, auth_config jsonb, enabled boolean, created_at)\n  - metrics_kpi(id, date, kpi_type enum('search_clicks','impressions','unique_visitors','chatbot_conversations','conversion_rate'), value numeric, meta jsonb, source varchar, created_at)\n  - gsc_search_stats(date, query, clicks, impressions, ctr, position)\n  - ga4_page_metrics(date, page_path, sessions, users, bounce_rate, avg_session_duration)\n  - chatbot_conversations(date, intent, conversations, satisfaction, accuracy)\n  - gads_campaign_stats(date, campaign_id, name, clicks, impressions, cost_micros, conversions, conv_rate)\n  - alerts_news(date, source, title, topic, sentiment, url)\n  - activity_feed(id, occurred_at timestamptz, type, message, meta jsonb)\n  - system_health(id, component, status, last_sync, details)\n  - export_jobs(id, user_id, params jsonb, status, file_url)\n- Add RLS policies: allow read/write for authenticated; stricter per table if needed.\n- Create indexes on date and query/campaign_id for performance.\n- Add Supabase service role key on server only; anon key for client read if necessary; use Edge-friendly client for Route Handlers.",
        "testStrategy": "- Run migration scripts via Supabase SQL editor; verify tables and RLS.\n- Insert/select sample rows; measure query performance.\n- Ensure server-side code can connect with service key; client only uses anon key if needed.",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Document Database Schema Structure",
            "description": "Design and document the structure for all required tables (metrics, data sources, logs, etc.), specifying columns, data types, enums, and relationships according to best practices for normalization, primary keys, and data integrity.",
            "dependencies": [],
            "details": "Include all specified tables (data_sources, metrics_kpi, gsc_search_stats, ga4_page_metrics, chatbot_conversations, gads_campaign_stats, alerts_news, activity_feed, system_health, export_jobs). Ensure each table has appropriate primary keys, data types, and consider normalization up to 3NF where practical.",
            "status": "pending",
            "testStrategy": "Review schema definitions for completeness and normalization. Validate with a schema visualization tool for correctness and clarity."
          },
          {
            "id": 2,
            "title": "Implement Schema in Supabase Using Migrations",
            "description": "Create and apply migration scripts to implement the designed schema in Supabase, using either SQL files or the Supabase CLI, and track all changes declaratively.",
            "dependencies": [
              "5.1"
            ],
            "details": "Use Supabase's migration system to apply schema changes. Store migration files in version control. Leverage declarative schema management for easier updates and rollback.",
            "status": "pending",
            "testStrategy": "Run migrations in a test environment. Verify all tables and columns are created as specified. Rollback and reapply migrations to ensure repeatability."
          },
          {
            "id": 3,
            "title": "Configure Row-Level Security (RLS) Policies",
            "description": "Define and apply RLS policies to enforce access control, allowing read/write for authenticated users and stricter rules for sensitive tables as needed.",
            "dependencies": [
              "5.2"
            ],
            "details": "Write RLS policies for each table, ensuring only authorized users can access or modify data. For sensitive tables, restrict access further based on user roles or ownership.",
            "status": "pending",
            "testStrategy": "Test access with different user roles. Attempt unauthorized access to verify policies are enforced. Review policy definitions for completeness."
          },
          {
            "id": 4,
            "title": "Optimize Schema with Indexes and Relationships",
            "description": "Create indexes on frequently queried columns (e.g., date, query, campaign_id) and define foreign key relationships where appropriate to improve query performance and data integrity.",
            "dependencies": [
              "5.2"
            ],
            "details": "Analyze query patterns to identify indexing needs. Add indexes to columns used in filters and joins. Define foreign keys for relational integrity where applicable.",
            "status": "pending",
            "testStrategy": "Benchmark query performance before and after indexing. Validate foreign key constraints by attempting invalid inserts/updates."
          },
          {
            "id": 5,
            "title": "Set Up Supabase Client Configuration for Server and Edge",
            "description": "Install @supabase/supabase-js ^2.45.0 and configure Supabase clients for both server (using service role key) and edge environments (using anon key as needed), ensuring secure key management.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Install the required client library. Configure environment variables for service role and anon keys. Set up client initialization code for both server and edge contexts, following Supabase security recommendations.",
            "status": "pending",
            "testStrategy": "Connect to Supabase from both server and edge environments. Verify correct key usage and access levels. Test basic CRUD operations from both contexts."
          }
        ]
      },
      {
        "id": 6,
        "title": "API Route Structure and Data Access Layer",
        "description": "Implement Next.js Route Handlers for each data domain and a shared data-access layer with caching.",
        "details": "- Create /app/api/{kpis,gsc,ga4,chatbot,gads,alerts,activity,exports}/route.ts with GET handlers.\n- Use a repository pattern: lib/repos/{kpiRepo,gscRepo,gaRepo,chatbotRepo,gadsRepo,alertsRepo}.ts reading/writing Supabase.\n- Add input validation with zod ^3.23 (e.g., date ranges, pagination, filters).\n- Server-side caching: fetch cache 'force-cache' for static ranges; revalidateTag for data updates. Use Next.js cache tags (revalidateTag) and route segment config for dynamic.\n- Implement error handling and standardized API response envelopes {data, meta, error}.\n- Include drill-down parameters (e.g., query, page_path, campaign_id) and sorting.\n- Rate limit internal APIs using upstash/ratelimit or simple token bucket in memory for now.",
        "testStrategy": "- Unit test each handler with supertest/next-test-api-route-handler.\n- Validate zod schemas reject invalid inputs.\n- Confirm caching works by observing revalidateTag behavior after writes.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Next.js API Route Handlers for Data Domains",
            "description": "Create route handlers in /app/api/{kpis,gsc,ga4,chatbot,gads,alerts,activity,exports}/route.ts, each supporting GET requests and dynamic drill-down parameters.",
            "dependencies": [],
            "details": "Set up Next.js route handler files for each data domain, ensuring support for dynamic segments and query parameters (e.g., query, page_path, campaign_id, sorting). Follow Next.js conventions for route structure and parameter extraction.",
            "status": "pending",
            "testStrategy": "Use supertest or next-test-api-route-handler to unit test each handler for correct routing and parameter parsing."
          },
          {
            "id": 2,
            "title": "Develop Shared Data Access Layer Using Repository Pattern",
            "description": "Implement repository modules in lib/repos/ for each data domain, encapsulating Supabase read/write logic and supporting caching hooks.",
            "dependencies": [
              "6.1"
            ],
            "details": "Create repository files (e.g., kpiRepo.ts, gscRepo.ts, gaRepo.ts, chatbotRepo.ts, gadsRepo.ts, alertsRepo.ts) that abstract Supabase operations. Ensure each repository exposes methods for data retrieval and mutation, and can be extended for caching.",
            "status": "pending",
            "testStrategy": "Unit test repository methods with mocked Supabase client to verify correct queries and data handling."
          },
          {
            "id": 3,
            "title": "Integrate Input Validation with Zod Schemas",
            "description": "Define and apply Zod v3.23 schemas for validating API inputs such as date ranges, pagination, filters, and drill-down parameters.",
            "dependencies": [
              "6.1"
            ],
            "details": "Create Zod schemas for each route's expected input. Apply validation in route handlers before invoking repository methods, returning standardized error responses for invalid inputs.",
            "status": "pending",
            "testStrategy": "Test that invalid inputs are rejected and valid inputs pass, using unit tests for schema validation."
          },
          {
            "id": 4,
            "title": "Implement Server-Side Caching and Cache Invalidation",
            "description": "Add server-side caching using Next.js fetch cache ('force-cache') for static ranges and revalidateTag for data updates, leveraging route segment config for dynamic caching.",
            "dependencies": [
              "6.2"
            ],
            "details": "Configure caching strategies in repository methods and route handlers. Use Next.js cache tags (revalidateTag) to invalidate cache on data updates, and ensure correct cache headers are set for static and dynamic data.",
            "status": "pending",
            "testStrategy": "Verify caching behavior by observing cache hits/misses and revalidateTag-triggered updates in tests."
          },
          {
            "id": 5,
            "title": "Standardize API Response Envelopes, Error Handling, and Rate Limiting",
            "description": "Ensure all API responses use a standardized envelope ({data, meta, error}), implement robust error handling, and add rate limiting using upstash/ratelimit or an in-memory token bucket.",
            "dependencies": [
              "6.1",
              "6.3"
            ],
            "details": "Wrap all responses in a consistent envelope structure. Implement error handling for validation, repository, and unexpected errors. Integrate rate limiting middleware for internal APIs to prevent abuse.",
            "status": "pending",
            "testStrategy": "Test for correct envelope structure, error propagation, and rate limiting under load."
          }
        ]
      },
      {
        "id": 7,
        "title": "Chatbot Analytics Integration (Priority Source)",
        "description": "Ingest chatbot interaction data and expose analytics endpoints and UI widgets.",
        "details": "- Identify chatbot source (e.g., Intercom, Dialogflow CX, custom logs). Implement n8n webhook or periodic pull to Supabase tables chatbot_conversations.\n- Metrics: conversation volume by date, top intents, response accuracy, satisfaction (CSAT), resolution rate.\n- UI: KPI cards and charts (line for volume trend, bar for intents, pie for resolutions).\n- Pseudo-code ingestion:\n  fetchChatbotData(range){ const rows = api.list(range); supabase.upsert('chatbot_conversations', rows, on conflict (date,intent)); }\n- Ensure timestamps in UTC; dedupe by (date,intent).\n- Add server actions to trigger manual resync.\n- Implement drill-down to view sample transcripts if available (store only metadata to remain GDPR-compliant).",
        "testStrategy": "- Seed with synthetic data; verify charts and KPIs compute correctly.\n- Backfill historical data and confirm totals match chatbot platform reports.\n- Test PII redaction and data retention policy.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify and Integrate Chatbot Data Sources",
            "description": "Determine all relevant chatbot platforms (e.g., Intercom, Dialogflow CX, custom logs) and implement data ingestion via n8n webhook or periodic pulls into Supabase tables.",
            "dependencies": [],
            "details": "Assess available chatbot sources, verify API/documentation, and configure secure data pipelines to the 'chatbot_conversations' table. Ensure ingestion supports both real-time and scheduled syncs, and that authentication and data access permissions are in place.",
            "status": "pending",
            "testStrategy": "Simulate data ingestion from each source, verify successful upsert to Supabase, and confirm deduplication by (date, intent)."
          },
          {
            "id": 2,
            "title": "Define and Compute Key Chatbot Analytics Metrics",
            "description": "Establish logic to calculate conversation volume by date, top intents, response accuracy, satisfaction (CSAT), and resolution rate from ingested data.",
            "dependencies": [
              "7.1"
            ],
            "details": "Design metric computation queries and aggregation logic, ensuring timestamps are stored in UTC and data is deduplicated. Prepare for drill-downs by storing only metadata for transcripts to remain GDPR-compliant.",
            "status": "pending",
            "testStrategy": "Seed with synthetic data and validate that all metrics are computed accurately and match expected results."
          },
          {
            "id": 3,
            "title": "Develop Analytics API Endpoints",
            "description": "Expose RESTful endpoints to serve computed chatbot analytics metrics and support drill-down queries for sample transcripts.",
            "dependencies": [
              "7.2"
            ],
            "details": "Implement endpoints for KPI retrieval, trend data, intent breakdowns, and resolution summaries. Include server actions for manual data resync and ensure endpoints support filtering by date range and intent.",
            "status": "pending",
            "testStrategy": "Unit test endpoints for correct data output, error handling, and GDPR compliance (no PII exposure)."
          },
          {
            "id": 4,
            "title": "Design and Implement Analytics UI Widgets",
            "description": "Create frontend components for KPI cards and charts (line for volume trend, bar for intents, pie for resolutions), and enable drill-down to sample transcripts.",
            "dependencies": [
              "7.3"
            ],
            "details": "Develop responsive UI widgets that consume analytics endpoints, visualize trends, and allow users to interactively explore metrics. Ensure UI supports manual resync triggers and displays empty/error states gracefully.",
            "status": "pending",
            "testStrategy": "Verify UI renders correctly with seeded and live data, matches backend metrics, and supports drill-down without exposing sensitive data."
          },
          {
            "id": 5,
            "title": "Implement Data Quality, Compliance, and Monitoring",
            "description": "Ensure data deduplication, UTC timestamping, GDPR compliance (metadata-only transcripts), and set up monitoring for ingestion and analytics accuracy.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Automate checks for duplicate records, enforce UTC on all timestamps, redact or avoid storing PII, and monitor ingestion jobs for failures or anomalies. Document data retention and compliance policies.",
            "status": "pending",
            "testStrategy": "Backfill historical data, confirm totals match chatbot platform reports, and test PII redaction and retention policy enforcement."
          }
        ]
      },
      {
        "id": 8,
        "title": "Google Search Console API Integration",
        "description": "Connect to GSC Search Analytics API for queries, clicks, impressions, CTR, position; store and visualize.",
        "details": "- Use OAuth 2.0 service account or OAuth client; for internal dashboard, use service account with site delegated access or 3LO with admin consent.\n- Library: googleapis ^137.0.0.\n- Endpoint: searchconsole.searchanalytics.query with dimensions ['query','date','page'] as needed; pageSize limit.\n- Ingestion job writes to gsc_search_stats; map fields.\n- Implement caching: store daily aggregates; re-fetch recent 3 days to correct late data.\n- UI components: top keywords table (clicks, impressions, CTR, position), trends line chart.\n- Add rate limiting and exponential backoff for 429s.\n- Secure credentials with Google Cloud Secret Manager or Vercel encrypted env vars.",
        "testStrategy": "- Connect to a test property and validate totals for a date range match GSC UI within expected variance.\n- Unit test transform functions.\n- Handle no-data and permission errors gracefully in UI.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Google Cloud Project and Enable Search Console API",
            "description": "Set up a Google Cloud project, enable the Google Search Console API, and create OAuth 2.0 credentials (service account or OAuth client) with appropriate delegated access for internal dashboard use.",
            "dependencies": [],
            "details": "Follow Google Cloud Console steps to create a project, enable the Search Console API, and generate credentials. Ensure service account has site delegated access or use 3LO with admin consent as required.",
            "status": "pending",
            "testStrategy": "Verify API access by authenticating and listing available Search Console sites for the account."
          },
          {
            "id": 2,
            "title": "Implement Secure Credential Storage and Access",
            "description": "Store API credentials securely using Google Cloud Secret Manager or Vercel encrypted environment variables, and ensure credentials are accessed securely by the ingestion and UI components.",
            "dependencies": [
              "8.1"
            ],
            "details": "Integrate secret management into the deployment pipeline. Ensure credentials are not exposed in logs or client-side code.",
            "status": "pending",
            "testStrategy": "Validate credentials retrieval in staging and production environments; check for unauthorized access attempts."
          },
          {
            "id": 3,
            "title": "Develop Data Ingestion and Caching Pipeline",
            "description": "Build a job to query the searchanalytics endpoint for queries, clicks, impressions, CTR, and position, map fields, and write results to the gsc_search_stats table. Implement caching for daily aggregates and re-fetch recent 3 days to correct late-arriving data.",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "Use googleapis ^137.0.0 library to call searchconsole.searchanalytics.query with dimensions ['query','date','page'] and handle pageSize limits. Store results in the database and implement logic to cache and update aggregates.",
            "status": "pending",
            "testStrategy": "Cross-check ingested data totals against GSC UI for a date range; unit test field mapping and cache refresh logic."
          },
          {
            "id": 4,
            "title": "Integrate Rate Limiting and Error Handling",
            "description": "Add logic for rate limiting and exponential backoff to handle API 429 errors, and ensure robust error handling for permission and no-data scenarios.",
            "dependencies": [
              "8.3"
            ],
            "details": "Monitor API response codes and implement retry strategies with exponential backoff for rate limits. Gracefully handle permission errors and empty data responses in both ingestion and UI layers.",
            "status": "pending",
            "testStrategy": "Simulate rate limit and permission errors; verify retries, backoff, and user-facing error messages."
          },
          {
            "id": 5,
            "title": "Build UI Components for Data Visualization",
            "description": "Create UI components to display top keywords (table with clicks, impressions, CTR, position) and trends (line chart), sourcing data from the gsc_search_stats table.",
            "dependencies": [
              "8.3",
              "8.4"
            ],
            "details": "Design and implement a responsive dashboard with a top keywords table and trends line chart. Ensure data is updated from cached aggregates and handles empty or error states.",
            "status": "pending",
            "testStrategy": "Validate UI renders with sample and empty data; confirm charts and tables match backend data and handle errors gracefully."
          }
        ]
      },
      {
        "id": 9,
        "title": "Google Analytics 4 Data API Integration",
        "description": "Fetch GA4 metrics (users, sessions, bounce rate, avg session duration, traffic sources) and persist.",
        "details": "- Use @google-analytics/data ^5.7.0 with a service account; grant property read.\n- Reports: runReport with dimensions date, sessionDefaultChannelGroup, pagePath; metrics users, sessions, averageSessionDuration, bounceRate, conversions if configured.\n- Store to ga4_page_metrics and optionally a sources table.\n- Implement sampling awareness; paginate rows; respect API quotas.\n- UI: traffic sources stacked bar, behavior flow (simplified step chart), page performance table.\n- Add custom event tracking on frontend via gtag or GA4 Measurement Protocol only if needed internally (avoid mixing with prod site unless specified).",
        "testStrategy": "- Cross-check totals with GA4 UI for the same date range.\n- Unit test mapping and deduping.\n- Validate charts render with empty states and large dataset performance.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Google Cloud Project and Service Account for GA4 API",
            "description": "Create a Google Cloud project, enable the Google Analytics Data API, and configure a service account with property read access. Generate and securely store the JSON key for authentication.",
            "dependencies": [],
            "details": "Follow Google Cloud Console steps to create a new project, enable the GA4 Data API, and create a service account with the necessary permissions. Download the JSON key and ensure secure handling to prevent unauthorized access.",
            "status": "pending",
            "testStrategy": "Verify service account access by listing available GA4 properties using the API and confirming no authentication errors."
          },
          {
            "id": 2,
            "title": "Implement GA4 Data Fetching Logic Using @google-analytics/data",
            "description": "Develop backend logic to authenticate with the GA4 Data API using the service account and fetch required metrics (users, sessions, bounce rate, average session duration, conversions) with dimensions (date, sessionDefaultChannelGroup, pagePath).",
            "dependencies": [
              "9.1"
            ],
            "details": "Use @google-analytics/data ^5.7.0 to call runReport with specified dimensions and metrics. Implement pagination to handle large result sets, and add logic to detect and flag sampled data. Ensure API quota limits are respected.",
            "status": "pending",
            "testStrategy": "Cross-check API results with GA4 UI for the same date range. Unit test pagination and sampling detection logic."
          },
          {
            "id": 3,
            "title": "Persist GA4 Metrics to Database Tables",
            "description": "Map and store the fetched GA4 metrics into the ga4_page_metrics table and, if required, a separate sources table for traffic sources.",
            "dependencies": [
              "9.2"
            ],
            "details": "Design or update database schemas for ga4_page_metrics and sources. Implement data mapping, deduplication, and upsert logic to handle repeated fetches and avoid data loss or duplication.",
            "status": "pending",
            "testStrategy": "Unit test data mapping and deduplication. Validate that repeated imports do not create duplicate records."
          },
          {
            "id": 4,
            "title": "Develop UI Components for GA4 Data Visualization",
            "description": "Build frontend components to visualize traffic sources (stacked bar), behavior flow (simplified step chart), and page performance (table) using the persisted data.",
            "dependencies": [
              "9.3"
            ],
            "details": "Design and implement React components for each visualization. Ensure charts handle empty states and large datasets efficiently. Integrate with backend endpoints to fetch processed data.",
            "status": "pending",
            "testStrategy": "Validate UI renders correctly with empty, small, and large datasets. Test chart interactivity and responsiveness."
          },
          {
            "id": 5,
            "title": "Implement Optional Custom Event Tracking via gtag or Measurement Protocol",
            "description": "Add custom event tracking on the frontend using gtag or GA4 Measurement Protocol, only if required for internal analytics (not for production site unless specified).",
            "dependencies": [
              "9.4"
            ],
            "details": "Integrate event tracking code conditionally, ensuring it is only active in internal or test environments. Document event schema and ensure no data is sent to production GA4 properties unless explicitly approved.",
            "status": "pending",
            "testStrategy": "Trigger custom events in the frontend and verify receipt in GA4 debug view. Confirm no events are sent from production environments unless specified."
          }
        ]
      },
      {
        "id": 10,
        "title": "Google Ads API Integration for Campaign Performance",
        "description": "Integrate Google Ads API to retrieve campaign KPIs and ROI metrics.",
        "details": "- Use google-ads-api v17 SDK or REST; requires developer token, OAuth, customer ID with read perms.\n- Query via GAQL for campaigns: clicks, impressions, cost_micros, conversions, conversion_rate, date.\n- Persist in gads_campaign_stats; compute ROI if revenue available (else show CPA).\n- Handle paging and partial failures; respect per-customer rate limits.\n- UI: campaign table with sorting, cost and conversion trends, budget utilization gauge.\n- Secure refresh tokens; rotate credentials; store only on server.\n- Implement incremental sync by date; backfill last 90 days.",
        "testStrategy": "- Validate sample queries in the Ads UI vs API.\n- Unit test GAQL builders and error handling.\n- Simulate quota errors and ensure retries/backoff.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Authenticate and Authorize Google Ads API Access",
            "description": "Set up OAuth 2.0 authorization flow using developer token, client ID, and client secret to securely access the Google Ads API for the required customer accounts.",
            "dependencies": [],
            "details": "Implement secure storage for credentials and refresh tokens using environment variables or a secure vault. Ensure only server-side storage and periodic credential rotation.",
            "status": "pending",
            "testStrategy": "Validate OAuth flow by obtaining and refreshing access tokens; confirm access to Google Ads API endpoints for target customer IDs."
          },
          {
            "id": 2,
            "title": "Query Campaign Performance Metrics via GAQL",
            "description": "Use the google-ads-api v17 SDK or REST to construct and execute GAQL queries for campaign KPIs: clicks, impressions, cost_micros, conversions, conversion_rate, and date.",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement incremental sync by date and backfill for the last 90 days. Handle paging (fixed at 10,000 per page) and partial failures, respecting per-customer rate limits.",
            "status": "pending",
            "testStrategy": "Cross-check API query results with Google Ads UI for sample campaigns and date ranges; unit test GAQL query builders and error handling."
          },
          {
            "id": 3,
            "title": "Persist and Compute Campaign Statistics",
            "description": "Store retrieved campaign metrics in the gads_campaign_stats table and compute ROI if revenue is available, otherwise calculate CPA.",
            "dependencies": [
              "10.2"
            ],
            "details": "Design schema for gads_campaign_stats to support incremental updates. Implement logic to compute ROI and CPA, ensuring accurate mapping of metrics.",
            "status": "pending",
            "testStrategy": "Validate data persistence and correctness of ROI/CPA calculations with sample data; unit test database write operations and metric computations."
          },
          {
            "id": 4,
            "title": "Implement UI for Campaign Performance Visualization",
            "description": "Develop a campaign table UI with sorting, cost and conversion trends, and a budget utilization gauge to display campaign performance metrics.",
            "dependencies": [
              "10.3"
            ],
            "details": "Ensure the UI supports dynamic updates, sorting, and trend visualization. Integrate with backend to fetch and display persisted campaign stats.",
            "status": "pending",
            "testStrategy": "Verify UI renders correctly with sample and live data; test sorting, trend charts, and budget gauge for accuracy and responsiveness."
          },
          {
            "id": 5,
            "title": "Monitor, Handle Errors, and Optimize API Usage",
            "description": "Implement error handling for partial failures, paging, and rate limits; optimize API usage with batch operations and sparse updates where applicable.",
            "dependencies": [
              "10.2"
            ],
            "details": "Monitor for quota errors and apply exponential backoff strategies. Use batch processing and sparse object updates to reduce API calls and improve performance.",
            "status": "pending",
            "testStrategy": "Simulate quota and partial failure scenarios; unit test retry/backoff logic and batch/sparse update implementations for robustness."
          }
        ]
      },
      {
        "id": 11,
        "title": "Google Alerts/News API Integration",
        "description": "Pull industry insights via Google Alerts (via RSS) or News API alternative; store and display.",
        "details": "- If using Google Alerts: create alerts and fetch RSS feeds periodically; parse with rss-parser ^3.13.0.\n- Alternative: GNews/NewsAPI.org with API key; store title, source, url, date, topic, sentiment.\n- Add simple sentiment with sentiment npm or HuggingFace inference API (optional lightweight).\n- Display latest headlines list with filters; link out to source.\n- Persist to alerts_news; dedupe by url hash.",
        "testStrategy": "- Unit test RSS parsing and dedupe.\n- Validate UI renders and links work.\n- Check rate limits and caching headers respected.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Google Alerts or News API Source",
            "description": "Set up Google Alerts for relevant industry topics and configure RSS feed delivery, or alternatively, obtain API access for GNews/NewsAPI.org.",
            "dependencies": [],
            "details": "Define keywords and topics for monitoring. For Google Alerts, create alerts and set delivery to RSS feed. For News API alternatives, register and obtain API keys.",
            "status": "pending",
            "testStrategy": "Verify that alerts are created and RSS feeds or API endpoints return expected results for sample queries."
          },
          {
            "id": 2,
            "title": "Implement Feed Fetching and Parsing",
            "description": "Develop a scheduled job to fetch RSS feeds or API results periodically and parse the returned data using rss-parser or relevant API client.",
            "dependencies": [
              "11.1"
            ],
            "details": "Set up a polling mechanism to retrieve new items. Use rss-parser ^3.13.0 for RSS feeds or the official client for News APIs. Extract fields: title, source, url, date, topic.",
            "status": "pending",
            "testStrategy": "Unit test parsing logic with sample feeds and API responses; ensure all required fields are extracted."
          },
          {
            "id": 3,
            "title": "Deduplicate and Persist News Items",
            "description": "Store parsed news items in the alerts_news database, deduplicating entries by URL hash to prevent duplicates.",
            "dependencies": [
              "11.2"
            ],
            "details": "Generate a hash for each item's URL and check for existing entries before insertion. Persist all relevant metadata.",
            "status": "pending",
            "testStrategy": "Unit test deduplication logic with repeated and unique URLs; validate database persistence."
          },
          {
            "id": 4,
            "title": "Perform Sentiment Analysis on Headlines",
            "description": "Apply lightweight sentiment analysis to each headline using the sentiment npm package or HuggingFace inference API.",
            "dependencies": [
              "11.3"
            ],
            "details": "Integrate sentiment analysis into the ingestion pipeline. Store sentiment scores alongside news metadata.",
            "status": "pending",
            "testStrategy": "Validate sentiment scoring on a sample set of headlines; compare results between npm and HuggingFace approaches."
          },
          {
            "id": 5,
            "title": "Display and Filter Latest Headlines in UI",
            "description": "Develop a UI component to list the latest headlines with filtering options and direct links to sources.",
            "dependencies": [
              "11.4"
            ],
            "details": "Implement filters by topic, date, and sentiment. Ensure headlines are displayed with source, date, and link out. Integrate with alerts_news data.",
            "status": "pending",
            "testStrategy": "Validate UI renders correctly, filters work as expected, and links open the correct sources."
          }
        ]
      },
      {
        "id": 12,
        "title": "Real-time Updates, Live Activity Feed, and Data Freshness Indicators",
        "description": "Enable live synchronization and visibility into recent actions and system status.",
        "details": "- Use Supabase Realtime channels on activity_feed and system_health tables to push updates to clients.\n- Log significant events: sync start/finish, errors, user actions (exports, filters saved).\n- Display a Live Activity Feed component subscribing via supabase.channel('activity').\n- Data freshness badges per section: compute last_sync from system_health; color-code.\n- For real-time ingestion, integrate n8n workflows to POST to /api hooks which write and emit activity events.",
        "testStrategy": "- Simulate insert into activity_feed and verify UI updates without refresh.\n- Unit test freshness calculation.\n- Chaos test: send burst of events and ensure UI throttles rendering.",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Realtime Channels for activity_feed and system_health",
            "description": "Set up Supabase Realtime channels to listen for changes on the activity_feed and system_health tables, ensuring clients receive live updates.",
            "dependencies": [],
            "details": "Enable the Postgres Changes extension for both tables. Define channel topics and ensure RLS policies allow authorized clients to subscribe and receive updates. Test connectivity and message delivery for each channel.",
            "status": "pending",
            "testStrategy": "Simulate inserts and updates on both tables and verify that subscribed clients receive real-time notifications."
          },
          {
            "id": 2,
            "title": "Implement Event Logging for Significant Actions",
            "description": "Log key events such as sync start/finish, errors, and user actions (exports, filters saved) into the activity_feed table for real-time tracking.",
            "dependencies": [
              "12.1"
            ],
            "details": "Design a schema for activity_feed to capture event type, timestamp, user, and metadata. Integrate backend logic to write events to the table upon relevant triggers.",
            "status": "pending",
            "testStrategy": "Trigger each event type and confirm correct entries are created in activity_feed; validate event structure and completeness."
          },
          {
            "id": 3,
            "title": "Develop Live Activity Feed Component with Supabase Channel Subscription",
            "description": "Create a UI component that subscribes to the activity_feed channel and displays incoming events in real time.",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "Use Supabase client SDK to subscribe to the activity_feed channel. Render events as they arrive, with support for filtering and throttling to handle bursts.",
            "status": "pending",
            "testStrategy": "Simulate high-frequency event inserts and verify UI updates without page refresh; chaos test with event bursts to ensure UI performance."
          },
          {
            "id": 4,
            "title": "Compute and Display Data Freshness Badges per Section",
            "description": "Calculate last_sync timestamps from system_health and display color-coded freshness indicators for each dashboard section.",
            "dependencies": [
              "12.1"
            ],
            "details": "Query system_health for last_sync values. Implement logic to assign badge colors based on freshness thresholds. Integrate badges into relevant UI sections.",
            "status": "pending",
            "testStrategy": "Unit test freshness calculation logic; verify badge color changes as last_sync values update."
          },
          {
            "id": 5,
            "title": "Integrate n8n Workflows for Real-Time Ingestion and Event Emission",
            "description": "Set up n8n workflows to POST to API hooks, which write activity events and emit updates to Supabase Realtime channels.",
            "dependencies": [
              "12.2"
            ],
            "details": "Configure n8n to trigger on external events, POST to backend endpoints, and ensure backend writes to activity_feed and emits to Supabase channels. Validate end-to-end data flow.",
            "status": "pending",
            "testStrategy": "Trigger n8n workflows and confirm resulting activity events appear in the live feed and update all subscribed clients in real time."
          }
        ]
      },
      {
        "id": 13,
        "title": "n8n Workflow Automation for Data Collection",
        "description": "Configure n8n workflows to orchestrate pulls from sources and push to API webhooks.",
        "details": "- Deploy n8n (cloud or self-host). Create credentials for Google APIs, Ads, chatbot, and News.\n- Workflows:\n  - Scheduled daily GSC/GA4 pulls -> transform -> POST to /api/{gsc,ga4} bulk endpoints.\n  - Chatbot webhook receiver -> sanitize PII -> POST to /api/chatbot.\n  - Ads sync every 4 hours.\n  - Alerts RSS poll every 6 hours.\n- Include retry nodes, error branches to send notifications (email/Slack) and write to system_health.\n- Secure n8n to API via HMAC signature header checked in API routes.\n- Document workflows and environment variables.",
        "testStrategy": "- Run workflows in test mode; verify API receives signed payloads.\n- Force errors to ensure retries and error notifications function.\n- Confirm dedupe logic prevents duplicates on replays.",
        "priority": "medium",
        "dependencies": [
          6,
          7,
          8,
          9,
          10,
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Deploy and Secure n8n Instance",
            "description": "Set up n8n (cloud or self-hosted), configure user access, and secure API endpoints using HMAC signature headers.",
            "dependencies": [],
            "details": "Provision n8n on the chosen infrastructure. Implement access controls and configure HMAC signature verification on all API routes to ensure secure communication between n8n and the receiving APIs.",
            "status": "pending",
            "testStrategy": "Verify deployment accessibility, test HMAC signature validation with signed and unsigned requests, and confirm unauthorized requests are rejected."
          },
          {
            "id": 2,
            "title": "Configure Credentials for Data Sources",
            "description": "Create and store credentials for Google APIs (GSC, GA4), Ads platforms, chatbot, and News sources within n8n.",
            "dependencies": [
              "13.1"
            ],
            "details": "Use n8n's credential manager to securely add and test connections for each required data source, ensuring all necessary OAuth or API keys are present and functional.",
            "status": "pending",
            "testStrategy": "Test each credential by running a sample node to confirm successful authentication and data retrieval."
          },
          {
            "id": 3,
            "title": "Design and Implement Data Collection Workflows",
            "description": "Build n8n workflows for scheduled GSC/GA4 pulls, Ads sync, chatbot webhook receiver, and RSS polling, including data transformation and API POST actions.",
            "dependencies": [
              "13.2"
            ],
            "details": "Create workflows with appropriate triggers (schedule, webhook, polling), add transformation nodes, and configure POST requests to the respective /api endpoints. Ensure each workflow matches the required frequency and data structure.",
            "status": "pending",
            "testStrategy": "Run workflows in test mode, verify correct data is sent to APIs, and check that scheduling and triggers operate as intended."
          },
          {
            "id": 4,
            "title": "Implement Error Handling, Retries, and Notifications",
            "description": "Add retry nodes and error branches to workflows, sending notifications via email/Slack and logging to system_health on failure.",
            "dependencies": [
              "13.3"
            ],
            "details": "Configure error branches for all critical nodes, set up retry logic for transient failures, and integrate notification nodes for alerting. Ensure system_health logging captures error context.",
            "status": "pending",
            "testStrategy": "Force errors in workflows to confirm retries, notifications, and logging function as specified."
          },
          {
            "id": 5,
            "title": "Document Workflows and Environment Variables",
            "description": "Create comprehensive documentation for all workflows, credential setup, environment variables, and operational procedures.",
            "dependencies": [
              "13.4"
            ],
            "details": "Document workflow logic, scheduling, credential requirements, environment variable usage, and security practices. Provide setup and troubleshooting guides for future maintainers.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness and clarity; have a team member follow the documentation to replicate setup and workflow execution."
          }
        ]
      },
      {
        "id": 14,
        "title": "Visualization Components with Chart.js/Recharts and Drill-down",
        "description": "Build reusable chart wrappers and dashboard sections with interactivity, filters, and exports.",
        "details": "- Choose Recharts ^2.12.7 for composability or Chart.js ^4.4.3 with react-chartjs-2; pick one to avoid bloat. Recommend Recharts for React SSR friendliness.\n- Create ChartWrapper with loading, error, empty, legend toggle, and responsive container.\n- Components: LineChart (time series), BarChart (comparisons), PieChart (distribution), Heatmap (calendar heatmap using d3-scale + SVG).\n- Implement click handlers to set filters/context and navigate to drill-down routes with query params.\n- Time period selectors: day/week/month/quarter using date-fns ^3; maintain in URL state.\n- Export: client-side PNG export via html-to-image ^1.11; CSV export via json2csv; server export jobs for large reports using /api/exports with background job stub.\n- KPI Cards with trend computation: compare current period vs previous; show percentage delta with arrows (lucide icons).",
        "testStrategy": "- Snapshot test components.\n- Interaction tests with Playwright: drill-down navigation, filter persistence.\n- Validate export files open correctly and data matches visible charts.",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Select and Integrate Charting Library",
            "description": "Evaluate and choose between Recharts and Chart.js (with react-chartjs-2) for the dashboard, prioritizing composability, React SSR compatibility, and bundle size. Integrate the selected library into the project.",
            "dependencies": [],
            "details": "Recommend Recharts for React SSR friendliness and composability. Ensure only one library is included to avoid bloat. Set up the library with project tooling and verify compatibility with existing React components.",
            "status": "pending",
            "testStrategy": "Verify successful installation and rendering of a basic chart. Confirm no duplicate charting libraries are present in the bundle."
          },
          {
            "id": 2,
            "title": "Develop Reusable ChartWrapper Component",
            "description": "Create a ChartWrapper component that handles loading, error, and empty states, includes a legend toggle, and ensures responsive layout for all chart types.",
            "dependencies": [
              "14.1"
            ],
            "details": "Implement ChartWrapper to encapsulate common chart behaviors and UI states. Integrate legend toggle and responsive container using the charting library's features. Ensure accessibility and consistent styling.",
            "status": "pending",
            "testStrategy": "Snapshot and interaction tests for all states (loading, error, empty, legend toggle). Responsive layout tests across devices."
          },
          {
            "id": 3,
            "title": "Implement Core Chart Components",
            "description": "Build LineChart, BarChart, PieChart, and Heatmap components using the selected charting library and D3 where needed, ensuring each supports drill-down and filter interactivity.",
            "dependencies": [
              "14.2"
            ],
            "details": "Develop each chart type as a reusable component, leveraging ChartWrapper. For Heatmap, use d3-scale and SVG. Add click handlers to update filters/context and trigger navigation to drill-down routes with query parameters.",
            "status": "pending",
            "testStrategy": "Unit and interaction tests for each chart. Validate drill-down navigation and filter updates. Visual regression tests for chart rendering."
          },
          {
            "id": 4,
            "title": "Integrate Time Period Selectors and URL State Management",
            "description": "Add day/week/month/quarter selectors using date-fns, maintaining selected period and filters in the URL state for shareability and persistence.",
            "dependencies": [
              "14.3"
            ],
            "details": "Implement time period selectors with date-fns v3. Sync selected period and filters to the URL using React Router or equivalent. Ensure charts and dashboard sections reactively update based on URL state.",
            "status": "pending",
            "testStrategy": "Interaction tests for period selection and URL updates. Validate correct chart data for each period. E2E tests for filter persistence on navigation."
          },
          {
            "id": 5,
            "title": "Enable Chart Export and KPI Cards with Trend Analysis",
            "description": "Implement client-side PNG export (html-to-image), CSV export (json2csv), and server-side export stubs. Build KPI cards with trend computation, showing period-over-period deltas and arrow indicators.",
            "dependencies": [
              "14.4"
            ],
            "details": "Integrate export buttons for PNG and CSV. Set up server export API stub for large reports. Develop KPI cards that compute and display trends, using lucide icons for arrows. Ensure exports match visible chart data.",
            "status": "pending",
            "testStrategy": "Test export functionality for correctness and file integrity. Validate KPI trend calculations and visual indicators. E2E tests for export flows and KPI updates."
          }
        ]
      },
      {
        "id": 15,
        "title": "Performance, Accessibility, Deployment, and Monitoring",
        "description": "Optimize performance, ensure WCAG compliance, set up CI/CD, and deploy to production with monitoring.",
        "details": "- Performance: enable Next.js image optimization; use React Server Components for data fetching where possible; cache heavy queries; implement pagination/virtualization for large tables (react-virtualized or react-aria-components list).\n- Use edge runtime for lightweight APIs if feasible; add HTTP compression and proper cache headers.\n- Accessibility: run automated axe checks; ensure keyboard traps absent; provide alt text, aria labels; prefers-reduced-motion.\n- CI/CD: GitHub Actions to run lint, type-check, test, build; preview deploys.\n- Deployment: Vercel for Next.js 15; configure env vars and secrets; custom domain and HTTPS.\n- Monitoring: Vercel Analytics, Sentry ^8 for FE/BE error tracking, Logflare/Better Stack for logs; uptime monitoring.\n- Documentation: README, runbooks for API creds rotation, incident response.\n- Success criteria checks: page load <3s on 3G/Slow 4G, zero critical a11y issues, integration health dashboards.",
        "testStrategy": "- Lighthouse CI in GitHub Actions; budget thresholds.\n- Sentry test errors appear in dashboard.\n- Manual cross-browser testing in Chrome, Firefox, Safari, Edge; responsive device matrix.\n- Load test critical APIs with k6 to validate scalability.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Optimize Next.js Application Performance",
            "description": "Implement performance optimizations including enabling Next.js image optimization, using React Server Components for data fetching, caching heavy queries, and implementing pagination or virtualization for large tables. Utilize edge runtime for lightweight APIs, enable HTTP compression, and set proper cache headers.",
            "dependencies": [],
            "details": "Apply Next.js built-in optimizations such as the next/image component for image optimization, dynamic imports for code splitting and lazy loading, and server components for efficient data fetching. Configure caching strategies for both pages and API routes, and use edge runtime for APIs where feasible. Add HTTP compression and set Cache-Control headers to maximize performance.",
            "status": "pending",
            "testStrategy": "Measure page load times using Lighthouse CI with a target of <3s on 3G/Slow 4G. Validate caching and compression headers. Manually verify pagination/virtualization on large tables."
          },
          {
            "id": 2,
            "title": "Ensure Accessibility and WCAG Compliance",
            "description": "Conduct automated and manual accessibility checks to ensure compliance with WCAG standards, including running axe checks, verifying absence of keyboard traps, and providing appropriate alt text, aria labels, and prefers-reduced-motion support.",
            "dependencies": [],
            "details": "Integrate axe-core or similar tools for automated accessibility testing. Manually test keyboard navigation, focus management, and ensure all interactive elements are accessible. Provide descriptive alt text for images, use ARIA labels where necessary, and respect user preferences for reduced motion.",
            "status": "pending",
            "testStrategy": "Run automated axe checks in CI. Manually test keyboard navigation and focus order. Confirm zero critical accessibility issues in Lighthouse CI."
          },
          {
            "id": 3,
            "title": "Set Up CI/CD Pipeline with GitHub Actions",
            "description": "Configure GitHub Actions to automate linting, type-checking, testing, building, and preview deployments for the Next.js application.",
            "dependencies": [],
            "details": "Create workflows in GitHub Actions to run lint, type-check, and test jobs on pull requests and pushes. Automate build and preview deploys to Vercel. Ensure environment variables and secrets are securely managed in the CI/CD pipeline.",
            "status": "pending",
            "testStrategy": "Verify that all CI jobs pass on PRs and main branch. Confirm preview deploys are created for each PR. Ensure build fails on lint/type/test errors."
          },
          {
            "id": 4,
            "title": "Deploy to Production and Configure Monitoring",
            "description": "Deploy the optimized Next.js application to Vercel, configure custom domain and HTTPS, and set up monitoring with Vercel Analytics, Sentry for error tracking, and Logflare/Better Stack for logs and uptime monitoring.",
            "dependencies": [
              "15.1",
              "15.3"
            ],
            "details": "Deploy to Vercel with Next.js 15, ensuring environment variables and secrets are set. Configure custom domain and enforce HTTPS. Integrate Vercel Analytics for performance monitoring, Sentry v8 for frontend/backend error tracking, and Logflare or Better Stack for logging and uptime monitoring.",
            "status": "pending",
            "testStrategy": "Validate deployment on Vercel with custom domain and HTTPS. Confirm Sentry and log monitoring receive test errors and logs. Check uptime monitoring alerts."
          },
          {
            "id": 5,
            "title": "Document Performance, Accessibility, Deployment, and Monitoring Procedures",
            "description": "Create and maintain documentation including a comprehensive README, runbooks for API credential rotation and incident response, and success criteria checks for performance and accessibility.",
            "dependencies": [
              "15.1",
              "15.2",
              "15.3",
              "15.4"
            ],
            "details": "Write detailed documentation covering setup, deployment, monitoring, and troubleshooting. Include runbooks for rotating API credentials and handling incidents. Document success criteria such as page load targets, accessibility compliance, and integration health dashboards.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness and clarity. Validate that runbooks are actionable and up-to-date. Confirm success criteria are documented and tracked."
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Data Adapter Pattern for All Sources",
        "description": "Create standardized data adapters in src/lib/sources/ for Chatbot (Supabase), Google Search Console (Supabase cache), and Google Analytics 4 (API) to unify data fetching and shape.",
        "details": "Develop adapter modules: chatbot.ts, gsc.ts, ga.ts. Each should export functions (e.g., getChatbotSeries, getSearchSeries, getGaSeries) returning { totals, series } objects. Use Supabase JS v2 for database access and Google Analytics Data API v1beta for GA4 via a secure server-side API route. Ensure all adapters are fully type-safe using interfaces in types/analytics.ts. Mock data shapes for development using MSW or similar if APIs are unavailable.",
        "testStrategy": "Unit test each adapter with mocked data sources. Validate returned data shapes against TypeScript interfaces. Test error handling for unavailable APIs.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Unified Data Interfaces and Types",
            "description": "Establish TypeScript interfaces in types/analytics.ts that standardize the shape of data ({ totals, series }) returned by all adapters, ensuring type safety and consistency across sources.",
            "dependencies": [],
            "details": "Analyze the data requirements for Chatbot, Google Search Console, and Google Analytics 4. Define interfaces for totals and series objects, and document expected fields and types. Ensure these interfaces are extensible for future data sources.",
            "status": "done",
            "testStrategy": "Validate interfaces with TypeScript type checks and ensure all adapters conform to these definitions."
          },
          {
            "id": 2,
            "title": "Implement Chatbot Data Adapter (Supabase)",
            "description": "Develop src/lib/sources/chatbot.ts to fetch and shape chatbot analytics data from Supabase, exporting a function (getChatbotSeries) that returns data in the unified format.",
            "dependencies": [
              "16.1"
            ],
            "details": "Use Supabase JS v2 to query the relevant tables. Map the raw data to the standardized { totals, series } structure. Handle errors and edge cases, ensuring the adapter is simple and focused.",
            "status": "done",
            "testStrategy": "Unit test with mocked Supabase responses. Validate output against the unified interfaces and test error handling."
          },
          {
            "id": 3,
            "title": "Implement Google Search Console Adapter (Supabase Cache)",
            "description": "Develop src/lib/sources/gsc.ts to fetch and shape Google Search Console data from the Supabase cache, exporting a function (getSearchSeries) that returns data in the unified format.",
            "dependencies": [
              "16.1"
            ],
            "details": "Query cached GSC data in Supabase using Supabase JS v2. Transform the data to match the standardized interfaces. Ensure clear and consistent naming conventions for functions and variables.",
            "status": "done",
            "testStrategy": "Unit test with mocked Supabase cache data. Validate output structure and error handling."
          },
          {
            "id": 4,
            "title": "Implement Google Analytics 4 Adapter (API)",
            "description": "Develop src/lib/sources/ga.ts to fetch and shape Google Analytics 4 data via the Google Analytics Data API v1beta, exporting a function (getGaSeries) that returns data in the unified format.",
            "dependencies": [
              "16.1"
            ],
            "details": "Set up a secure server-side API route to call the GA4 Data API. Map the API response to the standardized { totals, series } structure. Handle authentication and API errors robustly.",
            "status": "done",
            "testStrategy": "Unit test with mocked GA4 API responses. Validate output against interfaces and test error scenarios."
          },
          {
            "id": 5,
            "title": "Integrate Mocking and Comprehensive Testing",
            "description": "Set up MSW or a similar tool to mock data shapes for all adapters during development and testing. Ensure all adapters are fully covered by unit tests, including error handling and type validation.",
            "dependencies": [
              "16.2",
              "16.3",
              "16.4"
            ],
            "details": "Configure MSW to intercept network/database requests and provide mock responses for each adapter. Write comprehensive unit tests for each adapter, covering normal and error cases, and validate returned data against TypeScript interfaces.",
            "status": "done",
            "testStrategy": "Run all unit tests with and without mocks. Use TypeScript to enforce type safety. Ensure adapters handle unavailable APIs gracefully."
          }
        ]
      },
      {
        "id": 17,
        "title": "Develop Overview Aggregation Logic",
        "description": "Implement lib/overview.ts getOverview() to fetch and aggregate data from all adapters, calculate deltas, and unify KPIs.",
        "details": "Use Promise.all for parallel data fetching from adapters. Calculate delta values vs previous periods for all KPIs. Attribute data sources in German. Output unified KPI structure for UI consumption. Ensure all calculations are locale-aware (de-DE).",
        "testStrategy": "Integration test with all adapters, including edge cases (missing data, partial failures). Validate delta calculations and KPI structure.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Parallel Data Fetching from All Adapters",
            "description": "Develop logic in getOverview() to fetch data from all configured adapters concurrently using Promise.all, ensuring efficient and robust error handling.",
            "dependencies": [],
            "details": "Use Promise.all to initiate all adapter data fetches in parallel. Ensure that each adapter's fetch function returns a promise and handle any errors according to fail-fast requirements. Aggregate all responses for further processing.",
            "status": "done",
            "testStrategy": "Integration test with mock adapters to verify all data is fetched in parallel and errors are handled as specified."
          },
          {
            "id": 2,
            "title": "Aggregate and Normalize Adapter Data",
            "description": "Combine and normalize the raw data from all adapters into a unified structure suitable for KPI calculation and UI consumption.",
            "dependencies": [
              "17.1"
            ],
            "details": "Map each adapter's output to a common schema, resolving differences in field names, data types, and structures. Ensure all KPIs are present and consistently formatted.",
            "status": "done",
            "testStrategy": "Unit test with sample adapter outputs to verify correct normalization and completeness of the unified structure."
          },
          {
            "id": 3,
            "title": "Calculate Delta Values for All KPIs",
            "description": "Implement logic to compute delta values for each KPI by comparing current and previous period data, handling missing or partial data gracefully.",
            "dependencies": [
              "17.2"
            ],
            "details": "For each KPI, calculate the difference and percentage change versus the previous period. Ensure calculations are robust to missing or incomplete historical data.",
            "status": "done",
            "testStrategy": "Unit and integration tests with various data scenarios (complete, missing, partial) to validate delta calculations."
          },
          {
            "id": 4,
            "title": "Attribute Data Sources in German and Ensure Locale Awareness",
            "description": "Ensure all data source attributions are provided in German and that all number/date formatting is locale-aware (de-DE).",
            "dependencies": [
              "17.2"
            ],
            "details": "Translate all data source labels to German. Apply de-DE locale formatting to all numbers, dates, and percentages in the output.",
            "status": "done",
            "testStrategy": "Unit tests for correct German attribution and locale formatting; review output for compliance with de-DE standards."
          },
          {
            "id": 5,
            "title": "Output Unified KPI Structure for UI Consumption",
            "description": "Assemble the final unified KPI object, including current values, deltas, and source attributions, ready for direct use by the UI.",
            "dependencies": [
              "17.3",
              "17.4"
            ],
            "details": "Structure the output to match UI requirements, ensuring all KPIs, deltas, and attributions are present and correctly formatted. Document the output schema for frontend integration.",
            "status": "done",
            "testStrategy": "Integration test with the UI to validate structure, completeness, and correct rendering of all KPIs and metadata."
          }
        ]
      },
      {
        "id": 18,
        "title": "Build Date Range Picker and Granularity Toggle Controls",
        "description": "Create DateRangePicker.tsx and GranularityToggle.tsx components with URL state persistence and German labels.",
        "details": "Use shadcn/ui components and Zustand or useSearchParams for state management. Implement presets (Last 7/30/90 days, Custom). Ensure accessibility and responsive design. Persist state in URL query params for shareability. Use i18n for German labels.",
        "testStrategy": "Component unit tests for all presets and toggles. E2E test for URL state persistence and accessibility.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design DateRangePicker and GranularityToggle Component Interfaces",
            "description": "Define the props, state structure, and interaction flows for DateRangePicker.tsx and GranularityToggle.tsx, including support for presets and granularity options.",
            "dependencies": [],
            "details": "Specify required props for date range selection, preset options (Last 7/30/90 days, Custom), granularity toggles, and accessibility requirements. Ensure interfaces support i18n for German labels.",
            "status": "done",
            "testStrategy": "Review TypeScript interfaces for completeness and type safety. Validate accessibility attributes in component signatures."
          },
          {
            "id": 2,
            "title": "Implement DateRangePicker Component with Presets and Responsive Design",
            "description": "Build DateRangePicker.tsx using shadcn/ui components, supporting multi-month views, preset ranges, custom selection, and responsive layout.",
            "dependencies": [
              "18.1"
            ],
            "details": "Utilize Popover and Calendar from shadcn/ui for date selection. Integrate preset buttons for Last 7/30/90 days and Custom. Ensure mobile responsiveness and keyboard accessibility.",
            "status": "done",
            "testStrategy": "Unit test all preset selections, custom range input, and responsive behavior. Run accessibility audits for keyboard and screen reader support."
          },
          {
            "id": 3,
            "title": "Implement GranularityToggle Component with German Labels and Accessibility",
            "description": "Build GranularityToggle.tsx using shadcn/ui, allowing users to switch between daily and weekly views, with all labels in German and full accessibility compliance.",
            "dependencies": [
              "18.1"
            ],
            "details": "Use shadcn/ui Toggle or Select components. Integrate i18n for German labels. Ensure ARIA roles and keyboard navigation are implemented.",
            "status": "done",
            "testStrategy": "Unit test toggle functionality and label rendering. Validate accessibility with automated tools and manual keyboard navigation."
          },
          {
            "id": 4,
            "title": "Integrate State Management and URL Query Persistence",
            "description": "Connect both components to state management using Zustand or useSearchParams, persisting selected date range and granularity in URL query parameters for shareability.",
            "dependencies": [
              "18.2",
              "18.3"
            ],
            "details": "Implement logic to sync component state with URL query params. Ensure state updates reflect in the URL and vice versa. Support deep linking and browser navigation.\n<info added on 2025-08-13T12:47:41.503Z>\nâœ… MAJOR MILESTONE ACHIEVED! Date Range Picker and Granularity Toggle Controls are now fully implemented and integrated.\n\nThe implementation includes:\n- DateRangePicker component with German presets (\"Letzte 7 Tage\", \"Letzte 30 Tage\", etc.)\n- GranularityToggle component with \"TÃ¤glich\"/\"WÃ¶chentlich\" options\n- Full URL persistence via custom useAnalyticsState hook\n- Integration into chatbot page with clean UI layout\n- Responsive design across all device sizes\n- Complete TypeScript typing and error-free linting\n\nTechnical details:\n- Built with shadcn/ui Calendar, Popover, and ToggleGroup components\n- Custom useAnalyticsState hook manages URL state synchronization\n- German localization implemented with date-fns/locale\n- ARIA-compliant accessibility features\n- Styling consistent with dashboard theme\n\nUser experience features:\n- Control panel with muted background\n- Current date range duration display (\"Aktueller Zeitraum: X Tage\")\n- Preset selection with immediate URL updates\n- Custom date range selection with Apply/Cancel functionality\n- Mobile and desktop responsive layouts\n\nThe components are now ready for connection to data adapters in subsequent tasks.\n</info added on 2025-08-13T12:47:41.503Z>",
            "status": "done",
            "testStrategy": "E2E test for state persistence across reloads, URL updates, and shareability. Validate correct restoration of state from URL."
          },
          {
            "id": 5,
            "title": "Localize Components with i18n for German Labels and Validate Accessibility",
            "description": "Apply i18n to all user-facing labels and messages in both components, ensuring full German localization and accessibility compliance.",
            "dependencies": [
              "18.2",
              "18.3",
              "18.4"
            ],
            "details": "Configure i18n library for German translations. Audit all labels, tooltips, and ARIA attributes for correct localization and accessibility.",
            "status": "done",
            "testStrategy": "Unit test label rendering in German. Run accessibility checks for localized components. Validate with screen readers in German locale."
          }
        ]
      },
      {
        "id": 19,
        "title": "Integrate Source Badges and Enhanced KPI Cards",
        "description": "Develop SourceBadge.tsx and enhanced KPI cards with delta indicators and 'Heute vs Gestern' mini-KPIs.",
        "details": "Display badges for GA, GSC, and Chatbot using color-coded shadcn/ui badges. KPI cards should show current value, delta vs previous period, and mini-KPI for today vs yesterday. All labels in German. Ensure responsive grid layout.",
        "testStrategy": "Visual regression tests for badges and KPI cards. Unit tests for correct delta and mini-KPI calculations.",
        "priority": "medium",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement SourceBadge.tsx Component",
            "description": "Create a reusable SourceBadge.tsx component to display color-coded badges for GA, GSC, and Chatbot using shadcn/ui. Ensure badges are visually distinct and support German labels.",
            "dependencies": [],
            "details": "Implement badge rendering logic, color mapping, and label localization. Integrate with shadcn/ui and ensure accessibility.",
            "status": "pending",
            "testStrategy": "Visual regression tests for badge appearance and color; unit tests for correct label rendering."
          },
          {
            "id": 2,
            "title": "Develop Enhanced KPI Card Component Structure",
            "description": "Build the KPI card layout to display current KPI value, delta indicator vs previous period, and a mini-KPI for 'Heute vs Gestern'. All labels must be in German.",
            "dependencies": [],
            "details": "Design card structure with sections for main KPI, delta, and mini-KPI. Ensure proper label placement and translation.",
            "status": "pending",
            "testStrategy": "Unit tests for correct value and delta calculations; visual tests for layout and label accuracy."
          },
          {
            "id": 3,
            "title": "Implement Delta Indicator and Mini-KPI Logic",
            "description": "Add logic to calculate and display delta indicators (change vs previous period) and mini-KPI (today vs yesterday) within KPI cards.",
            "dependencies": [
              "19.2"
            ],
            "details": "Fetch or receive KPI data, compute delta and mini-KPI values, and render indicators with appropriate color coding and icons.",
            "status": "pending",
            "testStrategy": "Unit tests for delta and mini-KPI calculations; edge case tests for missing or zero data."
          },
          {
            "id": 4,
            "title": "Integrate Responsive Grid Layout for Badges and KPI Cards",
            "description": "Ensure badges and KPI cards are displayed in a responsive grid layout that adapts to various screen sizes.",
            "dependencies": [
              "19.1",
              "19.2"
            ],
            "details": "Use CSS grid or flexbox to arrange components. Test responsiveness and visual hierarchy across breakpoints.",
            "status": "pending",
            "testStrategy": "Visual regression tests on multiple viewport sizes; manual tests for mobile and desktop layouts."
          },
          {
            "id": 5,
            "title": "Localize All UI Labels to German",
            "description": "Translate and verify all UI labels, including badge names and KPI card text, to German for consistency.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3"
            ],
            "details": "Implement localization using i18n or static translation. Review for completeness and accuracy.",
            "status": "pending",
            "testStrategy": "Unit tests for label translation; manual review by German-speaking stakeholder."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Recharts-Based Time Series Visualizations",
        "description": "Create responsive chart components for traffic, search, and chatbot metrics using Recharts.",
        "details": "Develop TrafficTimeSeries.tsx, SearchTimeSeries.tsx, and ChatbotTimeSeries.tsx in components/dashboard/charts/. Use Recharts v2.7+ for line and dual-axis charts. Add tooltips, legends, and support for daily/weekly granularity. Ensure mobile responsiveness and professional styling matching existing design.",
        "testStrategy": "Snapshot and visual regression tests. Unit tests for correct data mapping and granularity toggling.",
        "priority": "high",
        "dependencies": [
          17,
          18
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Chart Data Interfaces and Granularity Support",
            "description": "Establish TypeScript interfaces for time series data and implement logic to support both daily and weekly granularity toggling for all chart types.",
            "dependencies": [],
            "details": "Create or update interfaces in types/analytics.ts to represent the expected shape of traffic, search, and chatbot time series data. Implement utility functions or hooks to transform and aggregate data for daily and weekly views, ensuring compatibility with Recharts data requirements.",
            "status": "in-progress",
            "testStrategy": "Unit test data transformation utilities for correct aggregation and interface compliance. Validate with mock data for both granularities."
          },
          {
            "id": 2,
            "title": "Develop TrafficTimeSeries.tsx Component",
            "description": "Implement the TrafficTimeSeries.tsx component using Recharts to visualize traffic metrics as a responsive line or dual-axis chart.",
            "dependencies": [
              "20.1"
            ],
            "details": "Use Recharts v2.7+ components (e.g., LineChart, CartesianGrid, XAxis, YAxis, Tooltip, Legend) to render traffic data. Ensure the chart supports daily/weekly granularity, includes tooltips and legends, and adapts to mobile screens. Apply professional styling consistent with the dashboard design.",
            "status": "pending",
            "testStrategy": "Snapshot and visual regression tests. Unit tests for correct rendering and granularity toggling."
          },
          {
            "id": 3,
            "title": "Develop SearchTimeSeries.tsx Component",
            "description": "Implement the SearchTimeSeries.tsx component using Recharts to visualize search metrics as a responsive line or dual-axis chart.",
            "dependencies": [
              "20.1"
            ],
            "details": "Leverage Recharts components to display search performance data, supporting both daily and weekly views. Integrate tooltips, legends, and ensure mobile responsiveness. Match the component's appearance to the existing dashboard style guide.",
            "status": "pending",
            "testStrategy": "Snapshot and visual regression tests. Unit tests for data mapping and granularity switching."
          },
          {
            "id": 4,
            "title": "Develop ChatbotTimeSeries.tsx Component",
            "description": "Implement the ChatbotTimeSeries.tsx component using Recharts to visualize chatbot metrics as a responsive line or dual-axis chart.",
            "dependencies": [
              "20.1"
            ],
            "details": "Build the chart using Recharts primitives, supporting daily/weekly granularity, tooltips, and legends. Ensure the component is fully responsive and visually consistent with other dashboard charts.",
            "status": "pending",
            "testStrategy": "Snapshot and visual regression tests. Unit tests for correct data rendering and granularity toggling."
          },
          {
            "id": 5,
            "title": "Integrate and Validate Chart Components in Dashboard",
            "description": "Integrate the three chart components into the dashboard, ensuring seamless interaction, consistent styling, and accessibility compliance.",
            "dependencies": [
              "20.2",
              "20.3",
              "20.4"
            ],
            "details": "Place the chart components in their respective dashboard sections. Verify that all charts render correctly with real and mock data, support granularity toggling, and maintain accessibility and responsiveness across devices.",
            "status": "pending",
            "testStrategy": "End-to-end visual and accessibility testing. Manual QA for responsiveness, interaction, and design consistency."
          }
        ]
      },
      {
        "id": 21,
        "title": "Develop CSV Export System",
        "description": "Implement /api/export API route for CSV streaming and DownloadCsvButton.tsx with view selection.",
        "details": "Use fast-csv or papaparse for CSV generation. API route should stream data with proper Content-Disposition headers and Excel-compatible formatting. DownloadCsvButton.tsx allows users to select which view to export. Filenames include date ranges. Handle large datasets efficiently.",
        "testStrategy": "API tests for CSV output, headers, and error handling. E2E tests for download flow and file content validation.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design API Route for CSV Streaming",
            "description": "Create the /api/export API route that streams CSV data efficiently, supporting large datasets and setting proper Content-Disposition headers for file downloads.",
            "dependencies": [],
            "details": "Implement server-side CSV generation using fast-csv or papaparse. Ensure the route streams data to avoid memory overload and sets headers for Excel compatibility and correct filename formatting, including date ranges.",
            "status": "pending",
            "testStrategy": "Write API tests to validate streaming behavior, header correctness, and error handling for large datasets."
          },
          {
            "id": 2,
            "title": "Implement CSV Generation Logic",
            "description": "Develop logic to convert selected view data into CSV format, ensuring compatibility with Excel and handling locale-specific formatting as needed.",
            "dependencies": [
              "21.1"
            ],
            "details": "Integrate fast-csv or papaparse to serialize data. Ensure column headers and data rows are correctly mapped, and formatting (e.g., delimiters, encoding) is Excel-compatible. Support dynamic filename generation with date ranges.",
            "status": "pending",
            "testStrategy": "Unit test CSV output for various views and date ranges. Validate file structure and encoding in Excel."
          },
          {
            "id": 3,
            "title": "Build DownloadCsvButton.tsx with View Selection",
            "description": "Create a React component that allows users to select which view to export and initiates the CSV download process.",
            "dependencies": [
              "21.2"
            ],
            "details": "Design a UI for view selection and connect it to the export API. Ensure accessibility and usability. The button should trigger the API call and handle the file download, displaying appropriate feedback for success or errors.",
            "status": "pending",
            "testStrategy": "E2E tests for UI interaction, accessibility checks, and validation of download flow."
          },
          {
            "id": 4,
            "title": "Optimize for Large Dataset Handling",
            "description": "Ensure the export system efficiently manages large datasets, minimizing memory usage and maintaining responsive performance.",
            "dependencies": [
              "21.1",
              "21.2"
            ],
            "details": "Implement streaming and pagination strategies in the API. Test with large data volumes to prevent timeouts and memory leaks. Consider chunked responses or background processing if needed.",
            "status": "pending",
            "testStrategy": "Stress test with large datasets, monitor resource usage, and validate download completion."
          },
          {
            "id": 5,
            "title": "Validate End-to-End Export Flow",
            "description": "Test the complete CSV export workflow, from view selection to file download, ensuring correct data, headers, and filename formatting.",
            "dependencies": [
              "21.3",
              "21.4"
            ],
            "details": "Perform E2E tests covering all supported views, date range filename logic, and Excel compatibility. Include error scenarios and accessibility validation.",
            "status": "pending",
            "testStrategy": "Automated E2E tests for download flow, file content, and accessibility. Manual validation in Excel."
          }
        ]
      },
      {
        "id": 22,
        "title": "Enable Auto-Refresh and Real-Time Updates",
        "description": "Integrate SWR polling, Supabase Realtime subscriptions, and manual refresh for live dashboard updates.",
        "details": "Use SWR v2 with 60s polling for all data fetches. Subscribe to Supabase Realtime on relevant tables (chat, form) for instant updates. Add manual refresh button in header. Implement loading and error states using shadcn/ui feedback components. Ensure polling respects user activity (pause on inactivity).",
        "testStrategy": "Integration tests for polling, real-time updates, and manual refresh. Simulate new data and verify UI updates within 60s.",
        "priority": "high",
        "dependencies": [
          17,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SWR Polling for Data Fetching",
            "description": "Configure SWR v2 hooks with a 60-second polling interval for all relevant dashboard data fetches, ensuring efficient caching and deduplication.",
            "dependencies": [],
            "details": "Set up SWR with `refreshInterval: 60000` for each data endpoint. Ensure polling is paused when the user is inactive and resumes on activity. Use SWR's built-in features for cache management and revalidation.",
            "status": "pending",
            "testStrategy": "Simulate new data on the backend and verify that the UI updates within 60 seconds. Test polling pause/resume by simulating user inactivity and activity."
          },
          {
            "id": 2,
            "title": "Integrate Supabase Realtime Subscriptions",
            "description": "Subscribe to Supabase Realtime channels for the 'chat' and 'form' tables to receive and handle instant updates in the dashboard.",
            "dependencies": [
              "22.1"
            ],
            "details": "Use Supabase client to listen for insert, update, and delete events on the specified tables. Update the dashboard state immediately upon receiving relevant events.",
            "status": "pending",
            "testStrategy": "Insert, update, and delete rows in 'chat' and 'form' tables and verify that the dashboard reflects changes in real time without waiting for polling."
          },
          {
            "id": 3,
            "title": "Add Manual Refresh Button to Header",
            "description": "Implement a manual refresh button in the dashboard header that triggers immediate data revalidation for all SWR hooks.",
            "dependencies": [
              "22.1"
            ],
            "details": "Place a refresh button in the header UI. On click, call SWR's `mutate` function for all relevant keys to force immediate data fetch.",
            "status": "pending",
            "testStrategy": "Click the manual refresh button and verify that all dashboard data is re-fetched and updated instantly."
          },
          {
            "id": 4,
            "title": "Implement Loading and Error States with shadcn/ui",
            "description": "Display loading spinners and error messages using shadcn/ui feedback components during data fetches and on errors.",
            "dependencies": [
              "22.1",
              "22.2",
              "22.3"
            ],
            "details": "Wrap all data-dependent components with conditional rendering for loading and error states, using shadcn/ui components for consistent feedback.",
            "status": "pending",
            "testStrategy": "Simulate slow network and API errors to verify that loading indicators and error messages appear as expected."
          },
          {
            "id": 5,
            "title": "Ensure Polling Respects User Activity",
            "description": "Detect user inactivity and pause SWR polling when inactive, resuming polling when the user becomes active again.",
            "dependencies": [
              "22.1"
            ],
            "details": "Implement activity detection (e.g., mouse/keyboard events, visibility API). Integrate with SWR's polling control to pause and resume based on user presence.",
            "status": "pending",
            "testStrategy": "Simulate user inactivity (e.g., tab out, no interaction) and verify polling pauses. Resume activity and confirm polling restarts and data updates."
          }
        ]
      },
      {
        "id": 23,
        "title": "Upgrade Overview Page and Dashboard Layout",
        "description": "Refactor src/app/page.tsx to include new controls, KPI grid, charts, and data source captions.",
        "details": "Integrate DateRangePicker, GranularityToggle, SourceBadge, KPI cards, and chart components into the overview page. Add data source attribution caption in German. Ensure responsive layout and professional styling. Optionally include top pages/sources tables.",
        "testStrategy": "E2E tests for full dashboard flow. Visual regression and accessibility tests. Validate all controls and data views update as expected.",
        "priority": "medium",
        "dependencies": [
          18,
          19,
          20,
          22
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Dashboard Controls",
            "description": "Add and configure DateRangePicker, GranularityToggle, and SourceBadge components at the top of the overview page for interactive filtering and data selection.",
            "dependencies": [],
            "details": "Ensure controls are placed for optimal usability and accessibility, following dashboard design best practices for visual hierarchy and consistency.",
            "status": "pending",
            "testStrategy": "Verify each control renders, updates state, and triggers data refresh as expected. Include accessibility checks for keyboard and screen reader support."
          },
          {
            "id": 2,
            "title": "Implement KPI Grid and Cards",
            "description": "Design and add a responsive KPI grid displaying key metrics using reusable KPI card components, ensuring clear visual hierarchy and grouping.",
            "dependencies": [
              "23.1"
            ],
            "details": "Use modern UI frameworks and ensure cards are modular, visually distinct, and adapt to various screen sizes. Highlight trends and deltas where applicable.",
            "status": "pending",
            "testStrategy": "Test KPI card rendering with different data sets, validate responsiveness, and confirm correct calculation and display of all metrics."
          },
          {
            "id": 3,
            "title": "Integrate Chart Components",
            "description": "Embed chart components (e.g., line, bar, pie charts) to visualize trends and breakdowns of KPIs, ensuring alignment with the KPI grid and controls.",
            "dependencies": [
              "23.2"
            ],
            "details": "Select or build chart components that are interactive, performant, and visually consistent with the dashboard. Ensure charts update based on control selections.",
            "status": "pending",
            "testStrategy": "Perform visual regression and interaction tests to confirm charts render accurately and update in response to control changes."
          },
          {
            "id": 4,
            "title": "Add Data Source Attribution Caption (German)",
            "description": "Display a caption in German attributing data sources, positioned consistently below the main dashboard content.",
            "dependencies": [
              "23.3"
            ],
            "details": "Ensure the caption is styled professionally, uses correct German phrasing, and is accessible on all devices.",
            "status": "pending",
            "testStrategy": "Check caption visibility, correct translation, and responsiveness. Validate that it remains legible and does not overlap with other elements."
          },
          {
            "id": 5,
            "title": "Implement Optional Top Pages/Sources Tables and Finalize Responsive Layout",
            "description": "Optionally add tables for top pages and sources, and ensure the entire overview page layout is fully responsive and professionally styled.",
            "dependencies": [
              "23.4"
            ],
            "details": "Use modular table components and finalize layout adjustments for all breakpoints. Apply consistent styling and spacing throughout the page.",
            "status": "pending",
            "testStrategy": "Conduct E2E tests for table rendering, data accuracy, and layout responsiveness. Perform visual and accessibility audits for the complete dashboard."
          }
        ]
      },
      {
        "id": 24,
        "title": "Configure Environment and Secure API Credentials",
        "description": "Set up GA4 service account credentials in .env, validate environment with Zod, and implement graceful fallbacks.",
        "details": "Store GA4 credentials securely in .env (never expose to client). Use Zod v3 for runtime environment validation. Implement fallback logic for unavailable APIs (show mock data or error states). Document environment setup for developers.",
        "testStrategy": "Unit tests for environment validation. Manual tests for API failure scenarios and fallback behavior.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate and Securely Store GA4 Service Account Credentials",
            "description": "Create a Google Analytics 4 service account, generate a JSON key, and securely store the credentials in the project's .env file, ensuring they are never exposed to the client.",
            "dependencies": [],
            "details": "Follow Google Cloud Console steps to create a service account, generate a JSON key, and add the key's sensitive values to the .env file. Restrict file access and ensure .env is in .gitignore.",
            "status": "pending",
            "testStrategy": "Verify .env contains all required GA4 credentials and that credentials are not accessible from client-side code."
          },
          {
            "id": 2,
            "title": "Grant Service Account Access to GA4 Property",
            "description": "Assign the service account email appropriate permissions on the target GA4 property to enable API access.",
            "dependencies": [
              "24.1"
            ],
            "details": "In Google Analytics Admin, add the service account email as a user with at least Viewer access to the relevant property.",
            "status": "pending",
            "testStrategy": "Confirm the service account can successfully authenticate and retrieve data from the GA4 API."
          },
          {
            "id": 3,
            "title": "Implement Zod v3 Environment Schema Validation",
            "description": "Define and enforce a Zod schema for all required GA4 environment variables, ensuring runtime validation and type safety.",
            "dependencies": [
              "24.1"
            ],
            "details": "Create a Zod schema that matches the expected .env structure for GA4 credentials. Integrate validation at application startup to throw clear errors if variables are missing or malformed.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify that invalid or missing environment variables are caught and produce descriptive errors."
          },
          {
            "id": 4,
            "title": "Implement Graceful Fallbacks for GA4 API Unavailability",
            "description": "Design and implement logic to handle GA4 API failures by providing mock data or clear error states to the user.",
            "dependencies": [
              "24.2",
              "24.3"
            ],
            "details": "Detect API errors (e.g., network issues, invalid credentials) and respond with fallback mock data or user-friendly error messages, ensuring the app remains usable.",
            "status": "pending",
            "testStrategy": "Manually simulate API failures and verify that fallback logic triggers as expected, displaying mock data or error states."
          },
          {
            "id": 5,
            "title": "Document Environment Setup and Fallback Behavior",
            "description": "Create clear developer documentation covering environment variable setup, Zod validation, and fallback logic for GA4 integration.",
            "dependencies": [
              "24.1",
              "24.3",
              "24.4"
            ],
            "details": "Write a setup guide detailing how to configure GA4 credentials, validate the environment, and understand fallback mechanisms. Include troubleshooting tips and security best practices.",
            "status": "pending",
            "testStrategy": "Have a developer follow the documentation from scratch and confirm successful environment setup and understanding of fallback behavior."
          }
        ]
      },
      {
        "id": 25,
        "title": "Ensure TypeScript Strict Mode and Code Quality Compliance",
        "description": "Audit and refactor codebase for TypeScript strict mode, code patterns, and styling conventions.",
        "details": "Enable strict mode in tsconfig.json. Refactor all new and existing code to resolve type errors. Enforce consistent code style with Prettier and ESLint. Reuse shadcn/ui components where possible. Maintain current file structure and styling approach.",
        "testStrategy": "Run tsc --noEmit for type checks. Lint and format all files. Code review for adherence to conventions.",
        "priority": "medium",
        "dependencies": [
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enable TypeScript Strict Mode in tsconfig.json",
            "description": "Update the project's tsconfig.json to set the 'strict' flag to true, ensuring all strict type checking options are enabled.",
            "dependencies": [],
            "details": "Edit tsconfig.json and set 'compilerOptions.strict' to true. Review and document any additional strict mode options that may be enabled by default.",
            "status": "pending",
            "testStrategy": "Run 'tsc --noEmit' to verify that strict mode is active and type errors are reported."
          },
          {
            "id": 2,
            "title": "Audit and Refactor Codebase for Type Errors",
            "description": "Systematically review all new and existing TypeScript code to identify and resolve errors or warnings introduced by strict mode.",
            "dependencies": [
              "25.1"
            ],
            "details": "Iterate through each file, fixing type errors, adding explicit types, and updating code patterns as needed to comply with strict mode requirements.",
            "status": "pending",
            "testStrategy": "Ensure 'tsc --noEmit' passes without errors on the entire codebase."
          },
          {
            "id": 3,
            "title": "Enforce Code Style with Prettier and ESLint",
            "description": "Configure and apply Prettier and ESLint to enforce consistent code style and linting rules across the codebase.",
            "dependencies": [
              "25.2"
            ],
            "details": "Update Prettier and ESLint configurations as needed. Run formatting and linting on all files, and fix any reported issues.",
            "status": "pending",
            "testStrategy": "Run 'npm run lint' and 'npm run format' to confirm zero lint or formatting errors."
          },
          {
            "id": 4,
            "title": "Refactor to Reuse shadcn/ui Components Where Possible",
            "description": "Identify opportunities to replace custom UI components with shadcn/ui equivalents to ensure consistency and reduce duplication.",
            "dependencies": [
              "25.2"
            ],
            "details": "Audit the codebase for custom UI implementations. Replace with shadcn/ui components where functionality and design match project requirements.",
            "status": "pending",
            "testStrategy": "Visually verify component replacements and run existing UI tests to ensure no regressions."
          },
          {
            "id": 5,
            "title": "Maintain File Structure and Styling Approach",
            "description": "Ensure all refactoring and code quality improvements preserve the current file organization and styling conventions.",
            "dependencies": [
              "25.2",
              "25.3",
              "25.4"
            ],
            "details": "Review all changes to confirm adherence to the established file structure and styling patterns. Document any necessary deviations with justification.",
            "status": "pending",
            "testStrategy": "Conduct code review to verify file structure and styling consistency are maintained."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-11T12:31:27.500Z",
      "updated": "2025-08-13T14:20:17.262Z",
      "description": "Tasks for master context"
    }
  }
}